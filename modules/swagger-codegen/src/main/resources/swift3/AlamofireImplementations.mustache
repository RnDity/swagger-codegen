// AlamofireImplementations.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Alamofire
import Timberjack

class AlamofireRequestBuilderFactory: RequestBuilderFactory {

    func getBuilder<T>() -> RequestBuilder<T>.Type {
        return AlamofireRequestBuilder<T>.self
    }
}

// Store manager to retain its reference
private var managerStore: [String: Alamofire.SessionManager] = [:]

open class AlamofireRequestBuilder<T>: RequestBuilder<T> {
    required public init(method: String, URLString: String, parameters: Any?, isBody: Bool) {
        super.init(method: method, URLString: URLString, parameters: parameters, isBody: isBody)
    }

    /**
     May be overridden by a subclass if you want to control the session
     configuration.
     */
    open func createSessionManager() -> Alamofire.SessionManager {
        let configuration = Timberjack.defaultSessionConfiguration()
        configuration.httpAdditionalHeaders = buildHeaders()
        if let requestTimeout = requestTimeout {
            configuration.timeoutIntervalForRequest = requestTimeout
        }
        return Alamofire.SessionManager(configuration: configuration)
    }

    /**
     May be overridden by a subclass if you want to control the Content-Type
     that is given to an uploaded form part.

     Return nil to use the default behavior (inferring the Content-Type from
     the file extension).  Return the desired Content-Type otherwise.
     */
    open func contentTypeForFormPart(fileURL: URL) -> String? {
        return nil
    }

    /**
     May be overridden by a subclass if you want to control the request
     configuration (e.g. to override the cache policy).
     */
    open func makeRequest(manager: SessionManager, method: HTTPMethod, parameters: Parameters?, encoding: ParameterEncoding) -> DataRequest {
        return manager.request(URLString, method: method, parameters: parameters, encoding: encoding)
    }

    override open func execute(_ completion: @escaping (_ response: Response<T>?, _ error: Error?) -> Void) {
        let managerId:String = UUID().uuidString
        // Create a new manager for each request to customize its request header
        let manager = createSessionManager()
        managerStore[managerId] = manager

        let xMethod = Alamofire.HTTPMethod(rawValue: method)
        
        var encoding:ParameterEncoding = URLEncoding()
        var fileKeys: [String]?
        var requestParameters: Parameters?
        
        if let parametersDictionary = parameters as? [String:Any] {
            fileKeys = parametersDictionary.filter { $1 is NSURL }.map { $0.0 }
            requestParameters = parametersDictionary
            
            if isBody {
                encoding = JSONEncoding()
            }
        } else if let parametersArray = parameters as? [Any] {
            requestParameters = parametersArray.asParameters()
            encoding = ArrayJSONEncoding()
        }

        if fileKeys?.count ?? 0 > 0 {
            manager.upload(multipartFormData: { mpForm in
                for (k, v) in self.parameters as! [String:Any] {
                    switch v {
                    case let fileURL as URL:
                        if let mimeType = self.contentTypeForFormPart(fileURL: fileURL) {
                            mpForm.append(fileURL, withName: k, fileName: fileURL.lastPathComponent, mimeType: mimeType)
                        }
                        else {
                            mpForm.append(fileURL, withName: k)
                        }
                        break
                    case let string as String:
                        mpForm.append(string.data(using: String.Encoding.utf8)!, withName: k)
                        break
                    case let number as NSNumber:
                        mpForm.append(number.stringValue.data(using: String.Encoding.utf8)!, withName: k)
                        break
                    default:
                        fatalError("Unprocessable value \(v) with key \(k)")
                        break
                    }
                }
                }, to: URLString, method: xMethod!, headers: nil, encodingCompletion: { encodingResult in
                switch encodingResult {
                case .success(let upload, _, _):
                    if let onProgressReady = self.onProgressReady {
                        onProgressReady(upload.progress)
                    }
                    self.processRequest(request: upload, managerId, completion)
                case .failure(let encodingError):
                    completion(nil, ErrorResponse(statusCode: 415, error: encodingError))
                }
            })
        } else {
            let request = makeRequest(manager: manager, method: xMethod!, parameters: requestParameters, encoding: encoding)
            if let onProgressReady = self.onProgressReady {
                onProgressReady(request.progress)
            }
            processRequest(request: request, managerId, completion)

            print("\n========================")
            
            if isBody {
                printJSONBody(forRequest: request.request)
            }
        }
    }

    private func printJSONBody(forRequest request: URLRequest?) {
        guard let request = request, let data = request.httpBody else {
            return
        }
        
        if let url = request.url?.absoluteString, let method = request.httpMethod {
            print("Request: \(method) \(url)")
        }
        
        do {
            let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers)
            let pretty = try JSONSerialization.data(withJSONObject: json, options: .prettyPrinted)
            
            if let string = NSString(data: pretty, encoding: String.Encoding.utf8.rawValue) {
                print("BODY: \(string)")
            }
        }
        catch {
            if let string = NSString(data: data, encoding: String.Encoding.utf8.rawValue) {
                print("Data: \(string)")
            }
        }
    }

    private func processRequest(request: DataRequest, _ managerId: String, _ completion: @escaping (_ response: Response<T>?, _ error: Error?) -> Void) {
        if let credential = self.credential {
            request.authenticate(usingCredential: credential)
        }

        let cleanupRequest = {
            _ = managerStore.removeValue(forKey: managerId)
        }

        let validatedRequest = request.validate()

        switch T.self {
        case is String.Type:
            validatedRequest.responseString(completionHandler: { (stringResponse) in
                cleanupRequest()

                if stringResponse.result.isFailure {
                    let errorResponse = makeErrorResponse(withStatusCode: stringResponse.response?.statusCode, data: stringResponse.data, error: stringResponse.result.error!, response: stringResponse.response)
                    completion(nil, errorResponse)
                    return
                }

                completion(
                    Response(
                        response: stringResponse.response!,
                        body: ((stringResponse.result.value ?? "") as! T)
                    ),
                    nil
                )
            })
        case is Void.Type:
            validatedRequest.responseData(completionHandler: { (voidResponse) in
                cleanupRequest()

                if voidResponse.result.isFailure {
                    let errorResponse = makeErrorResponse(withStatusCode: voidResponse.response?.statusCode, data: voidResponse.data, error: voidResponse.result.error!, response: voidResponse.response)
                    completion(nil, errorResponse)
                    return
                }

                completion(
                    Response(
                        response: voidResponse.response!,
                        body: nil),
                    nil
                )
            })
        case is Data.Type:
            validatedRequest.responseData(completionHandler: { (dataResponse) in
                cleanupRequest()

                if (dataResponse.result.isFailure) {
                    let errorResponse = makeErrorResponse(withStatusCode: dataResponse.response?.statusCode, data: dataResponse.data, error: dataResponse.result.error!, response: dataResponse.response)
                    completion(nil, errorResponse)
                    return
                }

                completion(
                    Response(
                        response: dataResponse.response!,
                        body: (dataResponse.data as! T)
                    ),
                    nil
                )
            })
        default:
            validatedRequest.responseJSON(options: .allowFragments) { response in
                cleanupRequest()

                if response.result.isFailure {
                    let errorResponse = makeErrorResponse(withStatusCode: response.response?.statusCode, data: response.data, error: response.result.error!, response: response.response)
                    completion(nil, errorResponse)
                    return
                }

                // handle HTTP 204 No Content
                // NSNull would crash decoders
                if response.response?.statusCode == 204 && response.result.value is NSNull{
                    completion(nil, nil)
                    return;
                }

                if () is T {
                    completion(Response(response: response.response!, body: (() as! T)), nil)
                    return
                }
                if let json: Any = response.result.value {
                    let body = Decoders.decode(clazz: T.self, source: json as AnyObject)
                    completion(Response(response: response.response!, body: body), nil)
                    return
                } else if "" is T {
                    // swagger-parser currently doesn't support void, which will be fixed in future swagger-parser release
                    // https://github.com/swagger-api/swagger-parser/pull/34
                    completion(Response(response: response.response!, body: ("" as! T)), nil)
                    return
                }

                completion(nil, ErrorResponse(statusCode: 500, error: NSError(domain: "localhost", code: 500, userInfo: ["reason": "unreacheable code"])))
            }
        }
    }

    private func buildHeaders() -> [String: String] {
        var httpHeaders = SessionManager.defaultHTTPHeaders
        for (key, value) in self.headers {
            httpHeaders[key] = value
        }
        return httpHeaders
    }
}

fileprivate func makeErrorResponse(withStatusCode statusCode: Int?, data: Data?, error: Error, response: HTTPURLResponse?) -> ErrorResponse {
    var errorResponse = ErrorResponse(statusCode: statusCode ?? 0, data: data, error: error)
    if statusCode == 400 {
        let result = Request.serializeResponseJSON(options: .allowFragments, response: response, data: data, error: nil)
        if case let Result.success(json) = result {
            let body = Decoders.decode(clazz: ValidationError.self, source: json as AnyObject)
            errorResponse.validationErrorMessage = body.message
            errorResponse.validationErrorDetails = body.details
        }
    }
    return errorResponse
}

fileprivate let arrayParametersKey = "arrayParametersKey"

extension Array {
    func asParameters() -> Parameters {
        return [arrayParametersKey: self]
    }
}

public struct ArrayJSONEncoding: ParameterEncoding {
    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        var urlRequest = try urlRequest.asURLRequest()
        
        guard let parameters = parameters,
            let array = parameters[arrayParametersKey] else {
                return urlRequest
        }
        
        do {
            let data = try JSONSerialization.data(withJSONObject: array, options: [])
            
            if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil {
                urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
            }
            
            urlRequest.httpBody = data
            
        } catch {
            throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
        }
        
        return urlRequest
    }
}
